Junk Yard Tracker Prototype — Design Document (Next.js + TypeScript, client-only) 0) Executive summary

We’re building a prototype inventory management UI for a local junkyard to manage vehicles. This version is frontend-only: no database, no backend, no server actions. Vehicles are stored in a demo local store in the browser (persisted via localStorage or IndexedDB).

The app supports:

4 vehicle types: Sedan, Coupe, Mini-Van, Motorcycle

Dynamic forms based on selected type

Strict runtime validation with clear errors

Automatic registration on creation (client-side), with visible status + error handling

Listing dashboard with mileage rating + sorting/filtering

Edit vehicle fields (but registration is immutable; to “redo” registration user deletes + recreates)

Unique nickname constraint (enforced in store + validation)

Deployed to Vercel as a standard Next.js app.

1. Goals, non-goals, constraints
   Goals

Type-safe domain model (discriminated unions, strict TS)

Simple UX: easy create → immediate feedback → dashboard clarity

Resilient client-only architecture: deterministic behavior, good error messaging, no flaky implicit server dependencies

Minimal dependencies while still having solid validation and maintainable forms

Non-goals (for this prototype)

Authentication / multi-user access

Real backend registration service or durable shared persistence

Complex reporting, export, audit trails

Offline-first conflict resolution across devices (we can support offline persistence locally, but no sync)

Constraints

No server-side actions assumed

Storage must be in-browser and suitable for quick demos

Must deploy cleanly to Vercel

2. User flows
   2.1 Vehicle creation flow (required)

User selects vehicle type (dropdown or radio)

Form updates to show type-specific fields

Client-side validation runs (Zod) and displays field-level errors

On successful validation, app attempts automatic registration (client-side)

App persists the vehicle and shows:

success toast/banner including registrationId, OR

failure messaging with registrationStatus = failed (vehicle is still created) and guidance

Design choice: registration happens as part of creation; it can fail. The vehicle can still be created with status failed so user can see and delete/recreate.

2.2 Listing & dashboard (required)

Show all vehicles with key fields:

Type, nickname (unique), mileage rating, registration ID, registration status, engine status, seat status (motorcycle)

Allow filtering & sorting (simple but useful)

2.3 Edit / delete / details

Edit vehicle’s non-registration fields (type-specific).

Registration cannot be changed/retired. If user needs a fresh registration, they delete and recreate.

Delete removes from local store.

3. Domain model and type safety
   3.1 Core types (discriminated unions)

We model vehicles as a union keyed by type. This ensures:

exhaustive rendering for forms/details (compile-time enforcement)

type-safe validation per vehicle type

safe table display logic

Shared enums

EngineStatus = 'works' | 'fixable' | 'junk'

SeatStatus = 'works' | 'fixable' | 'junk'

RegistrationStatus = 'registered' | 'failed' (prototype-only; see below)

Registration fields (immutable once set)

registrationId is present only when status is registered

registrationError is present only when status is failed

Base fields

id (UUID)

type

nickname (unique)

mileage (number)

engineStatus

createdAt, updatedAt

registration object

Note: We intentionally avoid pending unless we implement async registration simulation. If we add a short delay later, introduce pending and show a spinner badge.

3.2 Vehicle schemas (as given)

Sedan: wheels (0..4) default 4, doors (0..4) default 4

Coupe: wheels (0..4) default 4, doors (0..2) default 2

Mini-Van: wheels (0..4) default 4, doors (0..4) default 4, doorConfig array { sliding: boolean } default false

Motorcycle: wheels (0..2) default 2, seatStatus required

3.3 Mileage rating
type MileageRating = 'low' | 'medium' | 'high';

function calculateMileageRating(mileage: number): MileageRating {
if (mileage < 10000) return 'low';
if (mileage < 100000) return 'medium';
return 'high';
}

This is pure and used in the dashboard + detail view.

4. Validation strategy (strict + user-friendly)
   4.1 Libraries

Zod: schema validation + friendly error mapping

React Hook Form (recommended): minimal, common in Next.js, reduces custom form plumbing while keeping dependencies reasonable

Why RHF is still “minimal enough”:

it’s the de-facto standard for performant forms

pairs cleanly with Zod

avoids hand-rolled validation state, which is usually where prototypes become brittle

If the team wants even fewer libs: we can skip RHF and manage form state with useReducer, but it will be more code and more error-prone.

4.2 Validation rules (decisions)

nickname: required, trimmed, unique case-insensitively (decision below)

mileage: required, must be >= 0, integer (unless we decide decimals are acceptable)

wheels/doors: constrained to allowed unions

engineStatus/seatStatus: must be one of allowed values

mini-van doorConfig: must align with doors (see gap)

4.3 Uniqueness constraint (nickname)

We will enforce:

uniqueness by normalized nickname: normalize = trim + toLowerCase()

uniqueness checks at:

create: reject if nickname exists

edit: reject if nickname changes to an existing nickname (excluding self)

Why: avoids query collisions and aligns with requirement.

4.4 Error messaging requirements

Field errors: directly under each input

Form-level errors: banner at top of form (e.g., “Registration failed: …” or “Nickname already exists”)

Listing-level errors: when hydration/persistence fails (rare), show a non-blocking banner with “Reset demo data”

5. Client-only registration design
   5.1 What “registration” means in a client-only prototype

Since no backend exists, registration is a local step that generates a stable ID and may simulate failure. This ensures the UI handles failure states realistically.

5.2 Registration algorithm

On create:

validate vehicle data

attempt registration

if success → assign registrationId and set status='registered'

if failure → set status='failed' and set registrationError message

Registration ID is immutable once present; editing cannot alter it.

5.3 Failure simulation (decision needed)

We need to decide how failure occurs in prototype:

Option A (recommended): deterministic failures for known invalid conditions only (e.g., “nickname reserved”, mileage too high). This keeps demo stable.

Option B: random failure rate (e.g., 5%) to exercise UI handling; can be confusing in demos.

Given “keep simple,” I recommend Option A. If we still want to demonstrate failure UI, add a developer toggle: “Simulate registration failure”.

5.4 Registration status visible

In listing and details:

Badge: Registered / Failed

If failed, show tooltip or inline snippet of error

If registered, show registration ID prominently

6. Storage and state management (demo store)
   6.1 Storage option

Use localStorage for simplicity and Vercel-friendly deployment.

Tradeoff:

localStorage is synchronous and size-limited but acceptable for a prototype inventory.

IndexedDB is more scalable but more complexity.

Decision: start with localStorage with a single key: junkyard.vehicles.v1.

6.2 Store interface (SOLID-ish separation)

We separate concerns into small modules:

VehicleRepository (persistence boundary)

load(): Vehicle[]

save(vehicles: Vehicle[]): void

VehicleService (domain operations)

createVehicle(input): Result<Vehicle, DomainError>

updateVehicle(id, patch): Result<Vehicle, DomainError>

deleteVehicle(id): void

Enforces uniqueness, immutability rules, timestamps

RegistrationService (client-only registration)

register(vehicleDraft): Result<{registrationId}, RegistrationError>

This keeps UI components simple and testable.

6.3 State in React

To minimize libraries, use:

useReducer + Context for app state (vehicles list + filters)

Or, if team prefers, a tiny store like Zustand (but not necessary)

Recommendation: useReducer + Context is enough and avoids adding more dependencies.

6.4 Data migration/versioning

Because localStorage persists across deployments:

store a schema version: v1

if parsing fails or schema mismatch:

show banner “Demo data incompatible. Reset?”

provide one-click “Reset demo data” button (clears localStorage key)

7. UI design (simple, responsive, intuitive)
   7.1 UI stack

Tailwind CSS

No heavy component library required.

Use a small internal component set:

Buttons, Inputs, Select, RadioGroup, Badge, Modal/Dialog, Toast, Table

Optionally use shadcn/ui if the team wants speed and consistency (it’s common in Next.js + Tailwind), but it adds Radix dependencies and generated components.

Recommendation: Start with Tailwind + small internal components, add shadcn/ui only if the team wants faster polish.

7.2 Screens
Vehicles Dashboard (/vehicles)

Header: “Inventory”

Actions: “Add Vehicle”

Filter bar:

Search by nickname

Type filter (multi)

Registration status filter

Sort dropdown

Table (desktop) / Cards (mobile):

Nickname (unique)

Type

Mileage rating

Registration badge + ID

Engine badge (+ Seat badge when motorcycle)

Actions: View, Edit, Delete

Create Vehicle (/vehicles/new)

Step-like flow (can be single page):

Type selector at top

Dynamic fields below

Submit button

On success:

toast/banner with registration ID if registered

navigate back to dashboard (or stay with “Create another”)

Details (/vehicles/[id])

Summary card: nickname, type, rating, registration

Full field list depending on type

Actions: Edit / Delete

Edit (/vehicles/[id]/edit)

Same dynamic form as create, prefilled

Registration fields read-only; if failed, still read-only

If user wants new registration → delete & recreate (explain via helper text)

7.3 Status indicators

Engine status: badge (works/fixable/junk)

Seat status: badge for motorcycle only

Registration status: badge + ID (or error hint)

8. Routing & Next.js structure (Vercel deployment friendly)
   8.1 Next.js App Router

app/vehicles/page.tsx dashboard

app/vehicles/new/page.tsx create

app/vehicles/[id]/page.tsx details

app/vehicles/[id]/edit/page.tsx edit

Because we are client-only:

Pages that depend on localStorage must be Client Components ("use client").

Use a top-level provider in app/layout.tsx or app/vehicles/layout.tsx for the store context.

8.2 Suggested folder layout
src/
app/
layout.tsx
vehicles/
layout.tsx
page.tsx
new/page.tsx
[id]/page.tsx
[id]/edit/page.tsx
core/
domain/
vehicle.types.ts
mileageRating.ts
validation/
vehicle.schemas.ts
services/
vehicleService.ts
registrationService.ts
storage/
vehicleRepository.ts
localStorageAdapter.ts
ui/
components/
Badge.tsx
Button.tsx
Input.tsx
Select.tsx
RadioGroup.tsx
Table.tsx
Toast.tsx
vehicles/
VehicleForm.tsx
VehicleTypeSelector.tsx
fields/
SedanFields.tsx
CoupeFields.tsx
MiniVanFields.tsx
MotorcycleFields.tsx
VehicleTable.tsx
FiltersBar.tsx
state/
VehicleProvider.tsx
vehicleReducer.ts

8.3 Vercel deployment

Pure Next.js frontend deploy is straightforward.

No DB env vars required.

Ensure next.config.js is standard.

Confirm localStorage usage only occurs in client components to avoid SSR errors.

9. Sorting, filtering, and data shaping
   9.1 Minimal filters/sorts (recommended)

Filters:

nickname search (contains)

type (multi-select)

registration status (registered/failed)

engine status
Sorting:

createdAt desc (default)

nickname asc

mileage asc/desc

9.2 Table implementation

To avoid dependencies, we can implement sorting/filtering in memory with:

memoized selectors via useMemo

small helper functions

If the team wants a robust table quickly, TanStack Table is great but is an extra dependency. For prototype simplicity, implement manually.

10. ESLint/TypeScript standards (strict typing emphasis)
    10.1 TypeScript config

"strict": true

"noUncheckedIndexedAccess": true

"exactOptionalPropertyTypes": true

"noImplicitOverride": true (optional)

Avoid any entirely; prefer unknown + narrowing

10.2 ESLint

next/core-web-vitals

@typescript-eslint recommended rules

Prefer satisfies for configs and mapping objects (prevents type widening)

10.3 Design guardrails

All vehicle rendering uses exhaustive switches:

assertNever(vehicle.type) pattern

Validation is the single source of truth (Zod schemas)

Store/service boundaries prevent UI from mutating vehicles directly

11. Testing strategy (light but valuable)

Even for a prototype, a small suite will prevent regressions.

Unit tests:

calculateMileageRating

nickname normalization + uniqueness checks

registration service success/failure paths

Integration tests:

create vehicle → persisted → visible in listing

edit → updates listing

delete → removed

Optional E2E (if time):

Playwright: create flow + dashboard view

(If you want minimal deps, postpone E2E.)

12. Open decisions / gaps to finalize

These are the remaining things we should decide (or set defaults for) before implementation:

Mini-van doorConfig coupling

Should doorConfig.length === doors always?
Recommendation: Yes. When doors changes, auto-resize the array (preserve existing values).

Mileage numeric rules

integer-only vs allow decimals
Recommendation: integer-only for simplicity.

Case sensitivity of nickname uniqueness

treat “BlueCar” and “bluecar” as same?
Recommendation: yes (case-insensitive), using normalized nickname.

Registration failure simulation

deterministic rules vs random failures vs dev toggle
Recommendation: deterministic + optional dev toggle.

Edit behavior on vehicle type

allow changing type in edit?
Recommendation: no (keep stable; avoids migration of fields).

Delete semantics

soft delete vs hard delete
Recommendation: hard delete for prototype.

13. Assumptions (explicit)

Prototype is used by a single user on a single browser profile.

Persistence is “good enough” via localStorage; clearing browser storage resets inventory.

Registration is a client-side concept for demo purposes, not a real external system.

Unique nickname is a functional constraint and is used for easier querying/filtering in UI.

14. Recommended dependency list (minimal)

next, react, react-dom

typescript

tailwindcss (+ postcss/autoprefixer)

zod

recommended: react-hook-form + @hookform/resolvers (Zod resolver)

eslint + Next.js eslint config

Everything else is optional
