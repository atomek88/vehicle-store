4. Exact Zod schemas (recommended implementation)

Notes:

We treat mileage as an integer >= 0.

Wheels/doors follow the allowed unions exactly.

Mini-van doorConfig length is enforced to equal doors.

We default wheels/doors/engine/seat statuses when omitted.

Shared Zod pieces
import { z } from "zod";

export const EngineStatusSchema = z.enum(["works", "fixable", "junk"]);
export const SeatStatusSchema = z.enum(["works", "fixable", "junk"]);

export const SedanWheelsSchema = z.union([
z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4)
]);
export const SedanDoorsSchema = z.union([
z.literal(0), z.literal(1), z.literal(2), z.literal(3), z.literal(4)
]);

export const CoupeDoorsSchema = z.union([z.literal(0), z.literal(1), z.literal(2)]);

export const MotorcycleWheelsSchema = z.union([z.literal(0), z.literal(1), z.literal(2)]);

// Common required fields for all vehicle form inputs
export const NicknameSchema = z
.string()
.transform((s) => s.trim())
.refine((s) => s.length > 0, "Nickname is required")
.refine((s) => s.length <= 50, "Nickname must be 50 characters or fewer");

export const MileageSchema = z
.number({ invalid_type_error: "Mileage must be a number" })
.int("Mileage must be a whole number")
.min(0, "Mileage cannot be negative");

Form input schemas (pre-default, pre-registration)

These schemas validate only user-entered fields. Defaults are applied afterward.

SedanFormInputSchema
export const SedanFormInputSchema = z.object({
type: z.literal("sedan"),
nickname: NicknameSchema,
mileage: MileageSchema,

wheels: SedanWheelsSchema.optional(), // default 4
doors: SedanDoorsSchema.optional(), // default 4
engineStatus: EngineStatusSchema.optional() // default "works"
});

CoupeFormInputSchema
export const CoupeFormInputSchema = z.object({
type: z.literal("coupe"),
nickname: NicknameSchema,
mileage: MileageSchema,

wheels: SedanWheelsSchema.optional(), // default 4
doors: CoupeDoorsSchema.optional(), // default 2
engineStatus: EngineStatusSchema.optional() // default "works"
});

MiniVanFormInputSchema

Mini-van includes doorConfig. We allow doorConfig to be omitted; defaults derived based on doors.

export const MiniVanFormInputSchema = z.object({
type: z.literal("mini-van"),
nickname: NicknameSchema,
mileage: MileageSchema,

wheels: SedanWheelsSchema.optional(), // default 4
doors: SedanDoorsSchema.optional(), // default 4
doorConfig: z.array(z.object({ sliding: z.boolean() })).optional(),
engineStatus: EngineStatusSchema.optional() // default "works"
});

MotorcycleFormInputSchema
export const MotorcycleFormInputSchema = z.object({
type: z.literal("motorcycle"),
nickname: NicknameSchema,
mileage: MileageSchema,

wheels: MotorcycleWheelsSchema.optional(), // default 2
engineStatus: EngineStatusSchema.optional(),// default "works"
seatStatus: SeatStatusSchema.optional() // default "works"
});

VehicleFormInputSchema (discriminated union)
export const VehicleFormInputSchema = z.discriminatedUnion("type", [
SedanFormInputSchema,
CoupeFormInputSchema,
MiniVanFormInputSchema,
MotorcycleFormInputSchema
]);

export type VehicleFormInput = z.infer<typeof VehicleFormInputSchema>;

Persisted vehicle schemas (post-default + registration)

We enforce that persisted vehicles always contain:

id, timestamps

registration status shape

Registration schema
export const RegistrationSchema = z.union([
z.object({
status: z.literal("registered"),
registrationId: z.string().min(1),
}),
z.object({
status: z.literal("failed"),
registrationError: z.string().min(1),
}),
]);

Base persisted shape
export const VehicleBasePersistedSchema = z.object({
id: z.string().uuid(),
nickname: NicknameSchema, // already trimmed
mileage: MileageSchema,
engineStatus: EngineStatusSchema,
registration: RegistrationSchema,
createdAt: z.string().datetime(),
updatedAt: z.string().datetime(),
});

Persisted type schemas
export const SedanPersistedSchema = VehicleBasePersistedSchema.extend({
type: z.literal("sedan"),
wheels: SedanWheelsSchema,
doors: SedanDoorsSchema,
});

export const CoupePersistedSchema = VehicleBasePersistedSchema.extend({
type: z.literal("coupe"),
wheels: SedanWheelsSchema,
doors: CoupeDoorsSchema,
});

export const MiniVanPersistedSchema = VehicleBasePersistedSchema.extend({
type: z.literal("mini-van"),
wheels: SedanWheelsSchema,
doors: SedanDoorsSchema,
doorConfig: z.array(z.object({ sliding: z.boolean() })),
}).superRefine((val, ctx) => {
if (val.doorConfig.length !== val.doors) {
ctx.addIssue({
code: z.ZodIssueCode.custom,
message: "doorConfig length must match doors",
path: ["doorConfig"],
});
}
});

export const MotorcyclePersistedSchema = VehicleBasePersistedSchema.extend({
type: z.literal("motorcycle"),
wheels: MotorcycleWheelsSchema,
seatStatus: SeatStatusSchema,
});

export const VehiclePersistedSchema = z.discriminatedUnion("type", [
SedanPersistedSchema,
CoupePersistedSchema,
MiniVanPersistedSchema,
MotorcyclePersistedSchema,
]);

export type Vehicle = z.infer<typeof VehiclePersistedSchema>;

5. Default derivation rules (canonical)

Defaults apply after successful form validation:

Shared defaults

engineStatus: default "works"

Sedan defaults

wheels: 4

doors: 4

engineStatus: "works"

Coupe defaults

wheels: 4

doors: 2

engineStatus: "works"

Mini-van defaults

wheels: 4

doors: 4

engineStatus: "works"

doorConfig:

If omitted, create an array of length doors, each { sliding: false }

If provided and doors changes, reconcile:

If increasing doors: append { sliding: false }

If decreasing: truncate from the end

Always ensure doorConfig.length === doors

Motorcycle defaults

wheels: 2

engineStatus: "works"

seatStatus: "works"

6. Uniqueness validation (nickname)

Uniqueness is enforced at the service/store layer because it depends on existing state.
Rules:

Normalize both input and stored nicknames using normalizeNickname

Reject create if normalized nickname already exists

Reject edit if nickname changes to one already used by another vehicle

Suggested error shape:

code: NICKNAME_TAKEN

message: Nickname already exists. Choose a unique nickname.

7. Registration (client-only)

Registration runs after defaults are applied.

Persisted rule:

registration is one of:

{ status: "registered", registrationId: string }

{ status: "failed", registrationError: string }

Deterministic failure is recommended:

Example rule (optional): fail if nickname contains reserved substring like "fail-reg" to demo failures.

---

## `docs/specs/store-reducer-shape.md`

````md
# Store + Reducer Shape — Junk Yard Tracker (Client-only)

This defines the canonical state shape and reducer actions.

## 1) State goals

- Single source of truth for:
  - vehicle inventory
  - UI filtering/sorting
  - transient errors/toasts
- Client-only persistence via localStorage.
- No server actions.
- Enforce nickname uniqueness + registration immutability in service layer, not UI.

## 2) Core domain types (referenced)

- `Vehicle` (persisted union type)
- `VehicleFormInput` (form input union type)
- `MileageRating` (derived)
- `RegistrationStatus` (`registered` | `failed`)

## 3) State shape

````ts
export type SortKey = "createdAt" | "nickname" | "mileage";
export type SortDir = "asc" | "desc";

export type Filters = {
  query: string; // nickname search substring; normalized compare
  types: Array<Vehicle["type"]>; // empty => all
  registrationStatuses: Array<"registered" | "failed">; // empty => all
  engineStatuses: Array<"works" | "fixable" | "junk">; // empty => all
};

export type Sorting = {
  key: SortKey;
  dir: SortDir;
};

export type Toast = {
  id: string;
  kind: "success" | "error" | "info";
  title: string;
  message?: string;
};

export type VehicleState = {
  // inventory
  vehiclesById: Record<string, Vehicle>;
  vehicleOrder: string[]; // stable ordering; typically createdAt desc

  // derived UI controls
  filters: Filters;
  sorting: Sorting;

  // loading/persistence lifecycle
  hydration: {
    status: "idle" | "hydrating" | "ready" | "error";
    errorMessage?: string;
  };

  // transient UI messaging
  toasts: Toast[];
};

Initial state (recommended)
export const initialVehicleState: VehicleState = {
  vehiclesById: {},
  vehicleOrder: [],
  filters: {
    query: "",
    types: [],
    registrationStatuses: [],
    engineStatuses: [],
  },
  sorting: { key: "createdAt", dir: "desc" },
  hydration: { status: "idle" },
  toasts: [],
};

4) Actions (events)

We split actions into:

data actions (mutate inventory)

UI actions (filters/sorts)

hydration actions (localStorage load)

toast actions

export type VehicleAction =
  // hydration
  | { type: "HYDRATE_START" }
  | { type: "HYDRATE_SUCCESS"; payload: { vehicles: Vehicle[] } }
  | { type: "HYDRATE_ERROR"; payload: { message: string } }
  | { type: "RESET_DEMO_DATA" }

  // inventory
  | { type: "VEHICLE_CREATED"; payload: { vehicle: Vehicle } }
  | { type: "VEHICLE_UPDATED"; payload: { vehicle: Vehicle } }
  | { type: "VEHICLE_DELETED"; payload: { id: string } }

  // UI: filters/sorts
  | { type: "SET_QUERY"; payload: { query: string } }
  | { type: "SET_TYPES_FILTER"; payload: { types: Array<Vehicle["type"]> } }
  | { type: "SET_REG_STATUS_FILTER"; payload: { statuses: Array<"registered" | "failed"> } }
  | { type: "SET_ENGINE_STATUS_FILTER"; payload: { statuses: Array<"works" | "fixable" | "junk"> } }
  | { type: "SET_SORTING"; payload: { key: SortKey; dir: SortDir } }
  | { type: "CLEAR_FILTERS" }

  // toasts
  | { type: "TOAST_PUSH"; payload: { toast: Toast } }
  | { type: "TOAST_DISMISS"; payload: { id: string } };

5) Reducer rules (important invariants)
Inventory rules

vehiclesById is the authoritative record.

vehicleOrder contains IDs for display order.

When a vehicle is created:

add to vehiclesById

insert ID into vehicleOrder at correct position (default newest-first)

When updated:

replace in vehiclesById

keep ordering stable unless you choose to reorder by createdAt (recommend stable)

When deleted:

remove from vehiclesById

remove from vehicleOrder

Hydration rules

On load, parse localStorage key junkyard.vehicles.v1

If parse fails:

set hydration error and show "Reset demo data" UI

Reset clears storage and returns to initial state.

6) Selectors (derived view model)

All filtering/sorting is derived from state via selectors.

export function selectVehicles(state: VehicleState): Vehicle[] {
  // 1) map ordered ids -> vehicles
  // 2) filter by query/types/statuses/engine
  // 3) sort by state.sorting
  // 4) return list
}


Derived computed fields in UI:

mileage rating: calculateMileageRating(vehicle.mileage)

7) Service layer (recommended boundary)

Reducer is dumb; domain rules live in VehicleService:

createVehicle(input, existingVehicles): Result<Vehicle, DomainError>

validates (Zod)

applies defaults

checks nickname uniqueness

registers (client-only)

returns persisted Vehicle

updateVehicle(id, patch, existingVehicles): Result<Vehicle, DomainError>

validates type-specific patch

uniqueness check if nickname changes

forbids registration change (invariant)


---

## `docs/specs/ui-component-contracts.md`

```md
# UI Component Contracts — Props + Events (Junk Yard Tracker)

This document defines the canonical component interfaces so teams can build independently and integrate cleanly.

## 1) Shared UI primitives

### <Button />
Props:
- `variant?: "primary" | "secondary" | "danger" | "ghost"`
- `disabled?: boolean`
- `onClick?: () => void`
- `type?: "button" | "submit"`
- `children: ReactNode`

### <Input />
Props:
- `label: string`
- `value: string`
- `onChange: (next: string) => void`
- `placeholder?: string`
- `error?: string` (shows under input)
- `disabled?: boolean`

### <NumberInput />
Props:
- `label: string`
- `value: number | ""`
- `onChange: (next: number | "") => void`
- `error?: string`
- `min?: number`
- `step?: number`
- `disabled?: boolean`

### <Select />
Props:
- `label: string`
- `value: string`
- `options: Array<{ value: string; label: string }>`
- `onChange: (value: string) => void`
- `error?: string`
- `disabled?: boolean`

### <Badge />
Props:
- `variant?: "neutral" | "success" | "warning" | "danger"`
- `children: ReactNode`

### <ToastHost />
Events (via context or props):
- `onDismiss(id: string): void`

## 2) Vehicle-specific components

## 2.1 <VehicleTypeSelector />
Purpose: choose vehicle type; drives dynamic form rendering.

Props:
- `value: Vehicle["type"]`
- `onChange: (type: Vehicle["type"]) => void`
- `disabled?: boolean`

UX notes:
- Use radio buttons (fast) or a select (compact).
- Must be clear and accessible.

## 2.2 <VehicleForm />
Purpose: single form wrapper used for create and edit.

Props:
- `mode: "create" | "edit"`
- `initialValue: VehicleFormDraft` (see below)
- `existingNicknames: string[]` (normalized or raw; define consistently)
- `onSubmit: (draft: VehicleFormDraft) => void`
- `onCancel: () => void`

Events:
- `onSubmit` fires only if client-side validation passes.

Notes:
- Registration fields are not editable and not part of draft.
- For edit mode: type is fixed (recommended); disable type selector.

### VehicleFormDraft
The form draft mirrors VehicleFormInput but may include partial values while typing.

```ts
export type VehicleFormDraft = {
  type: Vehicle["type"];
  nickname: string;
  mileage: number | "";

  // optional fields depending on type
  wheels?: number; // constrained by type-specific UI
  doors?: number;  // constrained
  engineStatus?: "works" | "fixable" | "junk";
  seatStatus?: "works" | "fixable" | "junk";

  // mini-van only
  doorConfig?: Array<{ sliding: boolean }>;
};


Validation approach:

On submit, map draft -> VehicleFormInput and run Zod.

Field-level validation can be done on blur or on change.

2.3 Type-specific field groups
<SedanFields />

Props:

value: Pick<VehicleFormDraft, "wheels" | "doors" | "engineStatus">

onChange: (patch: Partial<VehicleFormDraft>) => void

errors?: Record<string, string | undefined>

disabled?: boolean

Expected onChange patches:

{ wheels: 4 }, { doors: 2 }, { engineStatus: "fixable" }

<CoupeFields />

Same as SedanFields but doors constrained to 0..2.

<MiniVanFields />

Props:

value: Pick<VehicleFormDraft, "wheels" | "doors" | "doorConfig" | "engineStatus">

onChange: (patch: Partial<VehicleFormDraft>) => void

errors?: Record<string, string | undefined>

disabled?: boolean

Additional rule:

When doors changes, UI must reconcile doorConfig length to match.

Provide a helper in core: reconcileDoorConfig(doors, doorConfig).

<MotorcycleFields />

Props:

value: Pick<VehicleFormDraft, "wheels" | "engineStatus" | "seatStatus">

onChange: (patch: Partial<VehicleFormDraft>) => void

errors?: Record<string, string | undefined>

disabled?: boolean

2.4 <RegistrationBadge />

Purpose: show registration status and associated id/error.

Props:

registration: Vehicle["registration"]

Behavior:

If registered: show success badge + registrationId

If failed: show danger badge + short error (tooltip or inline)

2.5 <VehicleTable />

Purpose: dashboard list view.

Props:

vehicles: Vehicle[] (already filtered/sorted by selector)

onView: (id: string) => void

onEdit: (id: string) => void

onDelete: (id: string) => void

Rendering requirements:

Columns:

nickname

type

mileage rating (derived)

registration (badge + id)

engine status badge

seat status badge (motorcycle only)

actions (view/edit/delete)

Responsive:

Table on desktop

Card list on mobile (optional but recommended)

2.6 <FiltersBar />

Purpose: control filtering/sorting.

Props:

filters: Filters

sorting: Sorting

onChangeFilters: (patch: Partial<Filters>) => void

onChangeSorting: (sorting: Sorting) => void

onClear: () => void

Must support:

query text

type filter

registration status filter

engine status filter

sorting

3) Page-level contracts
Dashboard page

Responsibilities:

Hydrate store on mount

Render FiltersBar + VehicleTable

Provide "Add Vehicle" CTA

Show hydration error with reset option

Create page

Responsibilities:

Provide empty defaults draft (type preselected or not)

On submit:

call VehicleService.createVehicle(draft, state.vehicles)

dispatch VEHICLE_CREATED

show toast (success/failure)

navigate to dashboard or remain for "Create another"

Edit page

Responsibilities:

Load vehicle by id

Map vehicle -> draft

On submit:

call VehicleService.updateVehicle(id, draft, state.vehicles)

dispatch VEHICLE_UPDATED

show toast

Registration is read-only.

Details page

Responsibilities:

Show read-only fields + badges

Actions: edit/delete

4) Error handling UX contract

Create/Edit:

Field-level errors under inputs

Form-level banner for:

nickname taken

unexpected persistence errors

registration failure result (only on create)

Dashboard:

If hydration/parsing fails:

show banner "Demo data invalid"

offer "Reset demo data"

Delete:

confirm dialog (recommended) to prevent accidental deletes


---

## Optional (but helpful): `docs/specs/shared-types.md`

If you want a single place to anchor cross-file naming:

```md
# Shared Type Names (Canonical)

- VehicleFormDraft: UI draft state shape during editing/creation
- VehicleFormInput: validated discriminated union (Zod inferred)
- Vehicle: persisted discriminated union with defaults + registration + timestamps
- Filters / Sorting / VehicleState: store contracts (see store-reducer-shape.md)
````
````
